package classReWriter;

import org.objectweb.asm.*;

public class ETClassWriter extends ClassWriter implements Opcodes {

  public ETClassWriter(final int flags, ClassLoader cl) {
    super(flags);
    // ETClass.setLoader(cl);  // uncomment if you want to load actual classes, etc.
  }

  /**
   * Returns the common super type of the two given types. The default
   * implementation of this method <i>loads<i> the two given classes and uses
   * the java.lang.Class methods to find the common super class. It can be
   * overridden to compute this common super type in other ways, in particular
   * without actually loading any class, or to take into account the class
   * that is currently being generated by this ClassWriter, which can of
   * course not be loaded since it is under construction.
   *
   * This version extends the default to use a different ClassLoader.
   *
   * @param type1 the internal name of a class.
   * @param type2 the internal name of another class.
   * @return the internal name of the common super class of the two given
   *         classes.
   */
  protected String getCommonSuperClass (final String type1, final String type2) {
    // this hack lets us compute frames internally for tracking uninitialized objects
    // and distinguishing pointers and non-pointers, but it is NOT good enough for
    // computing frames to load into a real JVM!
    return "java/lang/Object";

    // // The previous code, in case we need it back.
    // // A significant issue is finding and supply all the classes, since it sometimes
    // // requires ones that a compiler referred to but that are not in the run-time
    // // jars supplied with a benchmark.  This way seemed to lie madness!
    // ETClass c = ETClass.getClass(type1);
    // ETClass d = ETClass.getClass(type2);
    // if (c.isAssignableFrom(d)) {
    //   return type1;
    // }
    // if (d.isAssignableFrom(c)) {
    //   return type2;
    // }
    // if (c.isInterface || d.isInterface) {
    //   return "java/lang/Object";
    // } else {
    //   do {
    //     c = c.getSuperclass();
    //   } while (!c.isAssignableFrom(d));
    //   return c.className;
    // }
  }

  /*
  private static class ETClass {

    public final String className;
    public final String superName;
    public final String[] interfaces;
    public final boolean isInterface;

    private static Map<String, ETClass> classes = new HashMap<String, ETClass>();

    private static ClassLoader loader;

    public static void setLoader (ClassLoader loader) {
      ETClass.loader = loader;
    }

    public static ETClass getClass (String className) {
      if (className.equals("")) {
        return null;
      }
      ETClass c = classes.get(className);
      if (c == null) {
        String resourceName = className + ".class";
        InputStream is = loader.getResourceAsStream(resourceName);
        if (is != null) {
          try {
            ClassReader cr = new ClassReader(is);
            String superName = cr.getSuperName();
            String[] interfaces = cr.getInterfaces();
            int access = cr.getAccess();
            c = new ETClass(className, superName, interfaces, (access & ACC_INTERFACE) != 0);
            classes.put(className, c);
            is.close();
          } catch (IOException e) {
            is = null;
          }
        }
        if (is == null) {
          // System.err.println("Could not find class " + className);
          // System.exit(1);
        }
      }
      return c;
    }

    private ETClass (String className, String superName, String[] interfaces, boolean isInterface) {
      this.className   = className;
      this.superName   = superName;
      this.interfaces  = interfaces;
      this.isInterface = isInterface;
    }

    public ETClass getSuperclass () {
      return ETClass.getClass(superName);
    }

    public boolean isAssignableFrom (ETClass d) {
      if (this == d) {
        return true;
      }
      if (this.isInterface) {
        for (String superIntf : d.interfaces) {
          if (this.isAssignableFrom(ETClass.getClass(superIntf))) {
            return true;
          }
        }
        return false;
      } else if (d.className.equals("java/lang/Object")) {
        return false;
      } else {
        return this.isAssignableFrom(ETClass.getClass(d.superName));
      }
    }
  }
  */

}

// Local Variables:
// mode:Java
// c-basic-offset:2
// indent-tabs-mode:nil
// End:
