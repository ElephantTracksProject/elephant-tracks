<html><head><title>Elephant Tracks Documentation</title><style type="text/css">ol{margin:0;padding:0}.c11{list-style-type:disc;margin:0;padding:0}.c17{list-style-type:square;margin:0;padding:0}.c16{list-style-type:circle;margin:0;padding:0}.c9{padding-left:0pt;margin-left:144pt}.c8{color:inherit;text-decoration:inherit}.c13{color:#1155cc;text-decoration:underline}.c12{padding-left:0pt;margin-left:36pt}.c3{font-size:18pt;font-weight:bold}.c22{max-width:468pt;padding:72pt 72pt 72pt 72pt}.c14{font-size:10pt}.c15{padding-left:0pt}.c0{font-size:12pt}.c20{margin-left:108pt}.c21{text-decoration:underline}.c2{height:11pt}.c19{font-size:18pt}.c7{font-family:"Times New Roman"}.c5{font-family:"Courier New"}.c6{margin-left:72pt}.c4{font-weight:bold}.c10{background-color:#ffffff}.c23{margin-left:36pt}.c18{text-indent:36pt}.c1{direction:ltr}.title{padding-top:0pt;line-height:1.15;text-align:left;color:#000000;font-size:21pt;font-family:"Trebuchet MS";padding-bottom:0pt}.subtitle{padding-top:0pt;line-height:1.15;text-align:left;color:#666666;font-style:italic;font-size:13pt;font-family:"Trebuchet MS";padding-bottom:10pt}li{color:#000000;font-size:11pt;font-family:"Arial"}p{color:#000000;font-size:11pt;margin:0;font-family:"Arial"}h1{padding-top:10pt;line-height:1.15;text-align:left;color:#000000;font-size:16pt;font-family:"Trebuchet MS";padding-bottom:0pt}h2{padding-top:10pt;line-height:1.15;text-align:left;color:#000000;font-size:13pt;font-family:"Trebuchet MS";font-weight:bold;padding-bottom:0pt}h3{padding-top:8pt;line-height:1.15;text-align:left;color:#666666;font-size:12pt;font-family:"Trebuchet MS";font-weight:bold;padding-bottom:0pt}h4{padding-top:8pt;line-height:1.15;text-align:left;color:#666666;font-size:11pt;text-decoration:underline;font-family:"Trebuchet MS";padding-bottom:0pt}h5{padding-top:8pt;line-height:1.15;text-align:left;color:#666666;font-size:11pt;font-family:"Trebuchet MS";padding-bottom:0pt}h6{padding-top:8pt;line-height:1.15;text-align:left;color:#666666;font-style:italic;font-size:11pt;font-family:"Trebuchet MS";padding-bottom:0pt}</style></head><body class="c10 c22"><p class="c1"><span class="c3">Requirements</span></p><ol class="c16" start="1"><li class="c15 c20 c1"><span class="c0">ASM Bytecode Instrumentation Library 3.3:</span></li></ol><ol class="c17" start="1"><li class="c9 c1"><span class="c0 c13"><a class="c8" href="http://cs.tufts.edu/redline/elephantTracks/asm-all-3.3.jar">http://cs.tufts.edu/research/redline/elephantTracks/asm-all-3.3.jar </a></span></li></ol><ol class="c16" start="2"><li class="c15 c1 c20"><span class="c0">IBM&rsquo;s thread building blocks (including header files):</span></li></ol><ol class="c17" start="1"><li class="c1 c9"><span class="c13 c0"><a class="c8" href="http://threadingbuildingblocks.org/download#stable-releases">http://threadingbuildingblocks.org/download#stable-releases</a></span></li></ol><p class="c2 c1"><span class="c3"></span></p><p class="c1"><span class="c3">Building Elephant Tracks</span></p><p class="c2 c1"><span class="c0 c4"></span></p><p class="c1"><span class="c0">1. First, copy Makefile.inc to Makefile.local; in Makefile.local you will set local build parameters for your machine, in particular, you must set the following</span></p><ol class="c16" start="1"><li class="c15 c6 c1"><span class="c0">INSTALL_DIR -- Where you would like the Elephant Tracks binariest be isntalled</span></li><li class="c15 c6 c1"><span class="c0">ASMJAR -- Location of the asm.jar ( asm version &gt; 3.3)</span></li><li class="c15 c6 c1"><span class="c0">JAVA_PATH -- Must point to the home directory for java, not the actually java binary. (ie, the &lsquo;java&rsquo; binary should be in JAVA_PATH/bin/java)</span></li></ol><p class="c1"><span class="c0">2. make; make install</span></p><p class="c2 c1"><span class="c0"></span></p><p class="c1"><span class="c0 c4">Known Issue</span></p><p class="c2 c1"><span class="c0 c4"></span></p><p class="c1"><span class="c0">There is disagreement</span><span class="c0 c4">&nbsp;</span><span class="c0">between different versions of jni.h on the const-ness of certain parameters. This can lead to the following error when attempting to build Elephant Tracks:</span></p><p class="c2 c1"><span class="c0 c4"></span></p><p class="c1"><span class="c0 c4 c5">ETCallBackHandler.cpp: In function &lsquo;_jobject* instNewObjectA(JNIEnv*, jclass, jmethodID, const jvalue*)&rsquo;:<br>ETCallBackHandler.cpp:1385:66: warning: invalid conversion from &lsquo;const jvalue*&rsquo; to &lsquo;jvalue*&rsquo;</span></p><p class="c2 c1"><span class="c0 c5 c4"></span></p><p class="c1"><span class="c0 c5">This can be resolved by removing the -Werror g++ flag,</span></p><p class="c1"><span class="c0 c5">and adding -fpermissive.</span></p><p class="c2 c1"><span class="c0 c4"></span></p><p class="c2 c1"><span class="c0 c4"></span></p><p class="c2 c1"><span class="c0"></span></p><p class="c2 c1"><span class="c0"></span></p><p class="c1"><span class="c3">Running Elephant Tracks</span></p><p class="c1"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;First, make sure that INSTALL_DIR is in the LD_LIBRARY_PATH</span></p><p class="c2 c1"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Then run any Java program with Elephant Tracks like so:</span></p><p class="c2 c1"><span class="c14"></span></p><p class="c1"><span class="c14 c5">java -classpath &lt;other-paths&gt;:$ASMJAR -Xbootclasspath/a:$INSTALL_DIR \ -agentlib:ElephantTracks=&lt;ElephantTracks Options&gt;</span></p><p class="c2 c1"><span class="c14 c7"></span></p><p class="c1"><span class="c14 c7">&nbsp;</span><span class="c0 c7">&nbsp; Options:</span></p><p class="c1"><span class="c0 c7">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Are represented as name=value pairs, and may be given on the command like so:</span></p><p class="c2 c1"><span class="c14 c5"></span></p><p class="c1"><span class="c14 c5">-agentlib:ElephantTracks=:=name1=value1@name2=value2@...@nameN=valueN</span></p><p class="c2 c1"><span class="c7 c14"></span></p><p class="c1"><span class="c0 c7">&nbsp; &nbsp; &nbsp; Note that JVMs often impose an (undocumented) limit on the length of the command strings passed to a JVMTI agent such as Elephant Tracks, and will silently truncate if this is limit is exceeded. For this reason, it is recommend that infrequently changing options are stored in an option file, and specify that option file on the command line (see below).</span></p><p class="c2 c1"><span class="c0 c7"></span></p><p class="c2 c1"><span class="c0 c5"></span></p><ol class="c11" start="1"><li class="c1 c12"><span class="c0 c5 c10">optionsFile</span><span class="c0 c5">=&lt;option file&gt;</span></li></ol><ol class="c16" start="1"><li class="c15 c6 c1"><span class="c0 c7">This is a path to a file containing options (the same as</span></li></ol><p class="c1 c23"><span class="c0 c7">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;may be passed on the command line), one option per line.</span></p><ol class="c11" start="2"><li class="c12 c1"><span class="c0 c5">classPath=&lt;path&gt;</span></li></ol><p class="c1"><span class="c0 c7">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This is the path ElephantTracks will use to start its own Java process (not the one running your program). It must include INSTALL_DIR, INSTALL_DIR/elephantTracksRewriter.jar, and the asm-3.3 jar file.</span></p><p class="c1"><span class="c0 c7">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p><ol class="c11" start="1"><li class="c12 c1"><span class="c0 c7">&nbsp;</span><span class="c0 c5">javaPath=&lt;path to java executable&gt;</span></li></ol><ol class="c16" start="1"><li class="c15 c6 c1"><span class="c0 c7">This is the path to the actual java binary, not merely the directory </span></li></ol><p class="c1"><span class="c0 c7">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;it is in. (for example, /usr/bin/java, </span><span class="c0 c7 c21">not</span><span class="c0 c7">&nbsp;/usr/bin).</span></p><ol class="c11" start="2"><li class="c12 c1"><span class="c0 c5">namesFile=&lt;file name&gt;</span></li></ol><ol class="c16" start="1"><li class="c15 c6 c1"><span class="c0 c7">The file in which to output the names information (see below)</span></li></ol><ol class="c11" start="3"><li class="c12 c1"><span class="c0 c5">traceFile=&lt;file name&gt;</span></li></ol><ol class="c16" start="1"><li class="c15 c6 c1"><span class="c0 c7">The file in which to output the trace. You may also redirect trace output to a shell command with this syntax:</span></li></ol><p class="c6 c1 c18"><span class="c0 c5">traceFile=&gt;(shell command)</span></p><p class="c6 c1"><span class="c0 c7">For example:</span></p><p class="c6 c1"><span class="c0 c5">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;traceFile=&gt;(gzip &gt; foo.trace.gz)</span></p><p class="c1 c6"><span class="c0 c7">Would pipe the trace output to gzip, and redirect the output from gzip to foo.trace.gz</span></p><ol class="c11" start="4"><li class="c12 c1"><span class="c0 c5">bufferSize=&lt;number&gt;</span></li></ol><ol class="c16" start="1"><li class="c6 c1 c15"><span class="c0 c7">How many records to hold in Elephant Tracks&rsquo; internal buffer; larger values</span></li></ol><p class="c1"><span class="c0 c7">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;generally give better performance, but will use more memory (approximately 40 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;bytes per record).</span></p><p class="c2 c1"><span class="c0 c7"></span></p><p class="c1"><span class="c3">Record Types</span></p><p class="c2 c1"><span class="c3"></span></p><p class="c1"><span class="c3">Names File Records</span></p><p class="c1"><span>The entries in the names file map names of methods to numerical ids use in the trace.</span></p><p class="c2 c1"><span></span></p><p class="c1"><span class="c3"># Comment </span></p><p class="c1"><span class="c0">Lines that start with # are comments.</span></p><p class="c2 c1"><span></span></p><p class="c2 c1"><span></span></p><p class="c1"><span class="c3">C 0xcccc class-name [0xssss] (I:0xiiii)</span><span>*</span></p><p class="c1"><span>cccc = class id; ssss = superclass id;</span></p><p class="c1"><span>iiii = superinterface id</span></p><p class="c2 c1"><span></span></p><p class="c2 c1"><span class="c4"></span></p><p class="c1"><span class="c3">I 0xiiii interface-name [0xssss] (I:0xiiii)*</span></p><p class="c2 c1"><span class="c19"></span></p><p class="c1"><span>C or I will be output when the id is assigned, which is on first</span></p><p class="c1"><span>*mention*, and will be output again, possibly with more info,</span></p><p class="c1"><span>such as superclass / superinterfaces, when *processed*. &nbsp;We</span></p><p class="c1"><span>could perhaps distinguish a mention from a definition if you</span></p><p class="c1"><span>think it would be easier ...</span></p><p class="c2 c1"><span></span></p><p class="c1"><span class="c3">E 0xcccc class-name</span></p><p class="c1"><span>marks end of processing a class/interface *definition*</span></p><p class="c1"><span>(so now you know all the methods and fields)</span></p><p class="c2 c1"><span></span></p><p class="c1"><span>F I/S 0xffff name 0xcccc class-name field-type</span></p><p class="c1"><span>I = instance; S = static</span></p><p class="c1"><span>ffff = field id; cccc = declaring class id</span></p><p class="c1"><span>field-type is a descriptor (I, etc., or Jclassname; etc.)</span></p><p class="c2 c1"><span></span></p><p class="c1"><span>N 0xmmmm 0xcccc class-name method-name descriptor flags</span></p><p class="c1"><span>mmmm = method id; cccc = class id</span></p><p class="c1"><span>flags can include I or S for instance or static,</span></p><p class="c1"><span>with N added if native</span></p><p class="c1 c2"><span></span></p><p class="c1"><span class="c3">S 0xmmmm 0xcccc 0xssss descriptor dims</span></p><p class="c1"><span>For allocation sites</span></p><p class="c1"><span>mmmm = method id; cccc = declaring class id;</span></p><p class="c1"><span>ssss = site id (unique in run)</span></p><p class="c1"><span>descriptor = type of thing allocated</span></p><p class="c1"><span>dims = number of dimensions (0 for a scalar object)</span></p><p class="c2 c1"><span class="c3"></span></p><p class="c1"><span class="c3">Trace File Records</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp;The entiries in the trace file represent events in the program execution.</span></p><p class="c2 c1"><span class="c3"></span></p><p class="c1"><span class="c3"># Comment </span></p><p class="c1"><span class="c0">Lines that start with # are comments.</span></p><p class="c2 c1"><span class="c3"></span></p><p class="c1"><span class="c3">Allocation:</span></p><p class="c1"><span class="c0">There are several different kinds of allocation record, based on how the object was allocated. They all have the same general form:</span><span class="c3"><br>&lt;Type Character&gt; &lt;object-id&gt; &lt;size&gt; &lt;type&gt; &lt;site&gt; &lt;length&gt; &lt;thread-id&gt;</span></p><p class="c1"><span class="c3">Types:</span></p><p class="c1"><span class="c0 c4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A - </span><span class="c0">Array allocation</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c0 c4">I -</span><span class="c0">&nbsp;Initial Heap Allocation (Allocated before Elephant Tracks started)</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c0 c4">N </span><span class="c0">- Allocated via the NEW byte code in the traced java program</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c0 c4">P -</span><span class="c0">&nbsp;Preexisting object; these are objects for which Elephant Tracks missed the actual object allocation, but discovered later.This can be due to objects from the constant pool, or VM bugs.</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c0 c4">V -</span><span class="c0">&nbsp;Objects allocated by the virtual machine.</span></p><p class="c2 c1"><span class="c0"></span></p><p class="c1"><span class="c3">&nbsp; &nbsp; </span></p><p class="c2 c1"><span class="c3"></span></p><p class="c1"><span class="c3"><br></span><span class="c0">The new object has ID object-id, which is used to refer to the object in later events; the size in bytes; the type (a Java type as a string); length field is 0 for non-arrays, and the length of the array for arrays, the ID of the allocating thread. </span></p><p class="c2 c1"><span class="c0"></span></p><p class="c1"><span class="c0">The size is the size of the object in bytes as reported by the VM (this includes object headers and possibly other VM structures).<br></span><span class="c3"><br>Death:<br>D &lt;object-id&gt; &lt;thread-id&gt;</span></p><p class="c1"><span class="c0 c7">Object-id died, and its death occured in thread_id.</span></p><p class="c1"><span class="c3">&nbsp; </span></p><p class="c1"><span class="c3"><br>Field update:<br>U &lt;old-target-id&gt; &lt;object-id&gt; &lt;new-target-id&gt; &lt;field-id&gt; &lt;thread-id&gt;</span></p><p class="c1"><span class="c0">The field field-id in object object-id that used to point to old-target-id now points at new-target-id, and this update occured in thread-id.</span><span class="c3">&nbsp;<br><br></span><span class="c0">An object-id of 0 indicates that this is an update to a static field.</span><span class="c3"><br><br>Method entry:<br>M &lt;method-id&gt; &lt;receiver-object-id&gt; &lt;thread-id&gt;<br></span><span class="c0">A call to the method method-id with receiver object receiver-object-id in thread thread-id.<br></span><span class="c3"><br></span><span class="c0">A origin receiver of 0 indicates that this was a static method</span><span class="c3"><br><br>Method exit:<br>E &lt;method-id&gt; &lt;receiver-object-id&gt; &lt;thread-id&gt;</span><span class="c0"><br>Return from method method-id with receiver object receiver-object-id in thread thread-id.<br><br>A receiver of 0 indicates this was a static method.</span></p><p class="c2 c1"><span class="c0 c4"></span></p><p class="c1"><span class="c3">X &lt;method-id&gt; &lt;receiver-object-id&gt; &lt;exception-id&gt; &lt;thread-id&gt;</span></p><p class="c1"><span class="c0">Exceptional exit from a method method-id, with reciever object receiver-object-id, exception object exception-id, in thread thread-id</span></p><p class="c1"><span class="c3"><br>Exception Throw</span></p><p class="c2 c1"><span class="c3"></span></p><p class="c1"><span class="c3">T &lt;method-id&gt; &lt;receiver-id&gt; &lt;exception-object-id&gt; &lt;thread-id&gt;</span></p><p class="c1"><span class="c0">An exception was thrown in the given method, with the given receiver, and with the exception obejct itself having the given id.</span></p><p class="c2 c1"><span class="c0"></span></p><p class="c1"><span class="c3">Exception Handled</span></p><p class="c2 c1"><span class="c0"></span></p><p class="c1"><span class="c3">H &lt;method-id&gt; &lt;receiver-id&gt; &lt;exception-object-id&gt; &lt;thread-id&gt;</span></p><p class="c1"><span class="c0">An exception was handled in the given method, with the given receiver, and with the exception object itself having the given id.</span></p><p class="c2 c1"><span class="c0"></span></p><p class="c2 c1"><span class="c0"></span></p></body></html>